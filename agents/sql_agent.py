# agents/sql_agent.py

import sqlite3
import os
from google.cloud import storage
from dotenv import load_dotenv

# -----------------------------
# Helper function to fetch DB from GCS
# -----------------------------
def download_db_from_gcs(bucket_name, blob_name, local_path="/tmp/loans.db"):
    """Download SQLite DB from Google Cloud Storage"""
    client = storage.Client()
    bucket = client.bucket(bucket_name)
    blob = bucket.blob(blob_name)
    blob.download_to_filename(local_path)
    return local_path

# -----------------------------
# Helper function to clean SQL
# -----------------------------
import re

def clean_sql(sql_query: str) -> str:
    """
    Removes Markdown code fences and trims whitespace from SQL generated by LLMs.
    Handles ```sql, ```sqlite, and ``` fences.
    """
    if not sql_query:
        return ""
    fences = ["```sqlite", "```", "```sql", ]
    for fence in fences:
        sql_query = sql_query.replace(fence, "")
    return sql_query.strip()

# -----------------------------
# SQLAgent Class
# -----------------------------
class SQLAgent:
    def __init__(self, db_path=None):
        load_dotenv()
        self.db_path = db_path or download_db_from_gcs(
            bucket_name=os.getenv("LOAN_DB_BUCKET"),
            blob_name=os.getenv("LOAN_DB_BLOB")
        )

    # Connect to SQLite DB
    def _connect(self):
        return sqlite3.connect(self.db_path)

    # List tables in the DB
    def list_tables(self):
        conn = self._connect()
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = [row[0] for row in cursor.fetchall()]
        conn.close()
        return tables

    # Get columns for a table
    def get_table_schema(self, table_name):
        conn = self._connect()
        cursor = conn.cursor()
        cursor.execute(f"PRAGMA table_info({table_name});")
        schema = {row[1]: row[2] for row in cursor.fetchall()}  # {column_name: type}
        conn.close()
        return schema

    # Build schema description for prompt
    def build_schema_prompt(self):
        tables = self.list_tables()
        prompt_parts = []
        for table in tables:
            schema = self.get_table_schema(table)
            columns_str = ", ".join([f"{col} ({dtype})" for col, dtype in schema.items()])
            prompt_parts.append(f"Table '{table}' with columns: {columns_str}")
        return "\n".join(prompt_parts)

    # Convert NL -> SQL using Vertex AI Gemini
    def nl_to_sql(self, user_query):
        from google import genai
        from google.genai.types import HttpOptions

        schema_description = self.build_schema_prompt()
        print(schema_description)
        prompt = f"""
        You are a SQL generator with full knowledge of the database schema below.
        Before generating SQL, identify the **relevant tables and columns** based on the user question.

        Database schema:
        {schema_description}

        Question: {user_query}

        Rules:
        1. Only include columns that are relevant to answering the question.
        2. Always return **valid SQLite SQL** using the available tables and columns.
        3. If the question cannot be answered with the database, return: -- no query
        4. Think carefully about the question before generating SQL.

        Return **only the SQL query**. Do not include any explanation.
        """

        client = genai.Client(
            project=os.getenv("GCP_PROJECT"),
            location=os.getenv("GCP_REGION", "us-central1"),
            http_options=HttpOptions(api_version="v1")
        )

        predictions = client.models.generate_content(
            model="gemini-2.0-flash",
            contents=[prompt],
        )

        return clean_sql(predictions.text)

    # Execute SQL safely
    def execute_sql(self, sql_query):
        if not sql_query:
            return {"error": "Cannot convert query to SQL."}

        try:
            conn = self._connect()
            cursor = conn.cursor()
            cursor.execute(sql_query)
            columns = [desc[0] for desc in cursor.description]
            rows = cursor.fetchall()
            conn.close()
            return {"columns": columns, "rows": rows}
        except Exception as e:
            return {"error": str(e)}

    # Handle user query
    def handle_query(self, user_query):
        sql_query = self.nl_to_sql(user_query)
        print("Generated SQL:\n", sql_query)
        result = self.execute_sql(sql_query)
        return result


if __name__ == "__main__":
    agent = SQLAgent()
    print("Tables in DB:", agent.list_tables())
    query = "What is my next EMI?"
    result = agent.handle_query(query)
    print(result)
